### 양방향 연관관계
* 핵심은 단방향을 잘 설계하는 것이 중요하다.
* 비즈니스적으로 조회를 편하게 하기 위해 양방향 연관관계를 지정하는 것

### 다양한 연관관계
* 다대다 관계는 실무에서 쓰면 안 되는 수준

### 프록시와 연관관계
* 프록시
  * em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
  * em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 - DB에 쿼리가 안 날아가는데 객체가 조회
  * 실제 클래스를 상속 받아서 만들어지고 실제 클래스와 겉 모양이 같음.
  * 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용
  * 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것이 아니라 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
  * instance of 를 사용해야 한다
    * instance of 는 상속 관계에 있는 객체를 두고 자식 여부를 확인하는 것, ==은 서로 다른 객체의 주소값의 일치 여부
    * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 실제 엔티티를 반환한다.
  * **프록시를 사용하는 이유 !! Member는 Team과 연관관계를 가짐. 프록시를 사용하지 않아서 지연로딩을 사용할 수 없다면 Member를 JPA를 통해 조회할 때 연관관계인 Team까지 조회된다.
이게 문제가 되는 이유는, Member를 조회해서 어떤 로직을 처리하려는데 Team과 전혀 관련없는 일을 할 때. 나는 member만 필요한데 연관관계인 Team까지 다 불러와서 메모리에 올라와있는 것임. 만약 프록시
를 사용해서 지연로딩을 사용한다면, Member를 조회하고 Team과 전혀 관련없는 로직을 처리할 때 오로지 Member의 상태만으로 로직을 처리. getId를 하면 Id만 그 때 쿼리가 실행돼서 조회되니까!!**

### 즉시 로딩과 지연 로딩
* 지연 로딩(LAZY)
  * 연관관계에서 FetchType을 LAZY로 하면 프록시로 조회한다(찾는 메소드가 있을 때 쿼리 날아감)
  * 비즈니스 로직 상 Member만 조회하는 경우가 많으면 LAZY(프록시)
* 즉시 로딩(EAGER)
  * 연관관계에서 FetchType을 Eager로 하면 바로 JOIN 때려서 다 같이 조회함
  * 실무에서는 즉시 로딩 그냥 쓰지마라. 특히, JPQL에서 N+1 문제를 일으킨다. -> em.find 같은 경우는 JPA 가 하기 때문에 알아서 찾아서 한 번에 JOIN 쿼리를 날릴 수 있다.
하지만 JPQL은 쿼리문 그대로 SQL로 번역 돼서 가져오고 그 후에 Team이 있네? Eager네? 하고 부랴부랴 다음 SQL이 나간다.(Member를 가지고 왔더니 team이 즉시로딩이네? member의 갯수가 10개면 Team을 다 가져오기 위해 다시 쿼리가 나감)
  * @ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정
  * 만약에 예제 규모의 JOIN이 아니라 5개, 10개가 JOIN 걸려 있으면? EAGER 시 다 긁어온다. -> DBA 연락 온다
  * FetchJoin 이란 게 있는데, 이건 동적으로 내가 원하는 타이밍에만 바로 같이 가져올 수 있다.

### 영속성 전이(CASCADE)
* 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장(즉시로딩, 지연로딩과는 전혀 관계 없음~~)
* 연관관계에서 cascadeType 을 지정해주면 연속적으로 쿼리가 수행된다.
* 고아 객체 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티
* 개념적으로 부모를 제거하면 자식은 고아객체가 된다. 고아 객체도 같이 삭제되도록 해야 한다. orphanRemoval=true
* 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거, CascadeType.ALL과 orphanRemoval=true로 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음!
DDD의 Aggregate Root개념을 구현할 때 유용! < 먼지모르겠음 

### 값 타입
* 엔티티 타입
* 값 타입
* 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단!! 값 타입은 불변 객체로 설계.
  * 기본값 타입
    * 자바 기본 타입(primitive type)
    * 래퍼 클래스(Integer, Long)
    * String
    * 생명주기를 엔티티에 의존!!
    * 값 타입은 공유 X!! Integer나 String 같은 클래스는 공유 가능하지만 변경 X
  * 임베디드 타입(복합 값 타입)
    * 좌표를 묶어서 값으로 쓰고 싶을 때 클래스를 만들 수 있다
    * 임베디드 타입도 값 타입이라는 것 !!
    * @Embeddable 로 클래스에 선언 @Embedded 로 값 타입을 사용하는 곳에 표시
    * 기본 생성자 필수
    * 재사용, 높은 응집도, 해당 값 타입만 의미있는 메소드 작성 가능, 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존
    * 한 엔티티에서 같은 값 타입을 사용하면? AttributeOverrider를 사용해서 컬럼 명 속성을 재정의할 수 있다.
    * Setter를 없앰
    * 혹은 아예 새로 newAddress 인스턴스를 생성해서 값을 집어 넣음.
  * 컬렉션 값 타입
* 값 타입의 비교
  * 동일성 비교 : 인스턴스의 참조 값을 비교, == 사용
  * 동등성 비교 : 인스턴스의 값을 비교, equals() 사용
* 값 타입 컬렉션
  * 값 타입을 컬렉션에 담는 것
  * 값 타입을 하나 이상 저장할 때 사용, 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없음
  * 컬렉션을 저장하기 위한 별도의 테이블이 필요함
  * @ElementCollection 어노테이션과 @CollectionTable 어노테이션 사용해서 지정

### JPQL
* 나이가 18살 이상인 회원을 모두 검색하고 싶다면?
* 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
* 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능하고, 애플리케이션이 필요한 데이터만 DB에서 불러오려면 검색 조건이 포함된 SQL이 필요
* SQL을 추상화해서 특정 데이터베이스 SQL에 의존 X
* JPQL을 한 마디로 정의하면 객체지향 SQL
* 좀 동적으로 짜고 싶다? -> Criteria 사용... 근데 유지보수 안됨 왜? 못 알아봐서 -> 안 씀 -> QueryDSL을 사용하자!
* 네이티브 SQL : em.createNativeQuery()
* API
  * TypeQuery : 반환 타입이 명확할 때 사용
  * Query : 반환 타입이 명확하지 않을 때 사용
  * query.getResultList() : 결과가 하나 이상일 때 -> 결과가 없으면 빈 리스트 반환  
  * query.getSingleResult() :결과가 정확히 하나, 단일 객체 반환 -> 결과가 없으면 NoResultException, 둘 이상이면 NonUniqueResultException // 스프링 Data JPA 사용하면 -> 결과가 없으면 null 이나 Optional 반환함
  * 쿼리 파라미터 바인딩 = :username, query.setParameter(name, value);
* 프로젝션
  * SELECT 절에 조회할 대상을 지정하는 것
  * 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본 데이터 타입)
  * DISTINCT로 중복 제거  
  * 프로젝션으로 가져온 대상은 영속성 컨텐스트(1차 캐시)에서 다 관리된다.
  * 엔티티 프로젝션은 결과 대상이 몇 십 개 나올 수도 있는데, 다 관리된다.
  * 스칼라 타입의 경우 DTO를 통해서 받아올 수도 있다.(select 시 new 예약어로 만들어야 함)
* 페이징 API
  * query.setFirstResult(몇 번째부터).setMaxResults(몇 번째까지).getResultList();
* 조인
  * 세타 조인
    * 연관 관계 없는 거 막 쪼인
  * 조인 대상 필터링
    * SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = 'A'
    * == LEFT JOIN ON TEAM_ID = t.id and t.name ='A'
    * 아무 연관관계 없을 때 on을 통해 외부 조인 할 수 있다.
* 서브쿼리
  * JPA의 서브쿼리는 WHERE, HAVING 절에서만 사용 가능 하다
  * Hibernate에서는 select 절에서도 가능
  * ** FROM절의 서브쿼리(인라인 뷰)는 현재 JPQL에서 불가능 ** -> 정 안되면 네이티브,아니면 가져와서 애플리케이션에서 조작 하거나 쿼리를 두 번 분해해서 날림

### fetch join
* JPQL에서 성능 최적화를 위해 제공하는 기능
* 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
* fetchType.EAGER랑 비슷한 느낌
* ** 즉시 로딩과 fetch join은 아예 다른 기능이다!! **
  * em.find() 등을 통해서 엔티티 하나만 조회할 때 즉시 로딩으로 설정하면 연관된 팀도 한 쿼리로 가져오도록 최적화 되지만, 
  * JPQL을 사용하면 연관관계를 즉시로딩으로 설정하는 것과 상관없이 JPQL 자체만으로 SQL로 그대로 번역된다.
  * 그런데.. N+1 문제는 즉시로딩이라도 발생, 지연로딩이라도 발생, 일반 조인 모두 발생, fetch join만 발생 안함(즉시 member와 team을 한번에 join 해서 가져오기 때문에)
  * 