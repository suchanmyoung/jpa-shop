### 양방향 연관관계
* 핵심은 단방향을 잘 설계하는 것이 중요하다.
* 비즈니스적으로 조회를 편하게 하기 위해 양방향 연관관계를 지정하는 것

### 다양한 연관관계
* 다대다 관계는 실무에서 쓰면 안 되는 수준

### 프록시와 연관관계
* 프록시
  * em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
  * em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 - DB에 쿼리가 안 날아가는데 객체가 조회
  * 실제 클래스를 상속 받아서 만들어지고 실제 클래스와 겉 모양이 같음.
  * 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용
  * 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것이 아니라 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
  * instance of 를 사용해야 한다
    * instance of 는 상속 관계에 있는 객체를 두고 자식 여부를 확인하는 것, ==은 서로 다른 객체의 주소값의 일치 여부
    * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 실제 엔티티를 반환한다.
  * **프록시를 사용하는 이유 !! Member는 Team과 연관관계를 가짐. 프록시를 사용하지 않아서 지연로딩을 사용할 수 없다면 Member를 JPA를 통해 조회할 때 연관관계인 Team까지 조회된다.
이게 문제가 되는 이유는, Member를 조회해서 어떤 로직을 처리하려는데 Team과 전혀 관련없는 일을 할 때. 나는 member만 필요한데 연관관계인 Team까지 다 불러와서 메모리에 올라와있는 것임. 만약 프록시
를 사용해서 지연로딩을 사용한다면, Member를 조회하고 Team과 전혀 관련없는 로직을 처리할 때 오로지 Member의 상태만으로 로직을 처리. getId를 하면 Id만 그 때 쿼리가 실행돼서 조회되니까!!**

### 즉시 로딩과 지연 로딩
* 지연 로딩(LAZY)
  * 연관관계에서 FetchType을 LAZY로 하면 프록시로 조회한다(찾는 메소드가 있을 때 쿼리 날아감)
  * 비즈니스 로직 상 Member만 조회하는 경우가 많으면 LAZY(프록시)
* 즉시 로딩(EAGER)
  * 연관관계에서 FetchType을 Eager로 하면 바로 JOIN 때려서 다 같이 조회함
  * 실무에서는 즉시 로딩 그냥 쓰지마라. 특히, JPQL에서 N+1 문제를 일으킨다. -> em.find 같은 경우는 JPA 가 하기 때문에 알아서 찾아서 한 번에 JOIN 쿼리를 날릴 수 있다.
하지만 JPQL은 쿼리문 그대로 SQL로 번역 돼서 가져오고 그 후에 Team이 있네? Eager네? 하고 부랴부랴 다음 SQL이 나간다.(Member를 가지고 왔더니 team이 즉시로딩이네? member의 갯수가 10개면 Team을 다 가져오기 위해 다시 쿼리가 나감)
  * @ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정
  * 만약에 예제 규모의 JOIN이 아니라 5개, 10개가 JOIN 걸려 있으면? EAGER 시 다 긁어온다. -> DBA 연락 온다
  * FetchJoin 이란 게 있는데, 이건 동적으로 내가 원하는 타이밍에만 바로 같이 가져올 수 있다.

### 영속성 전이(CASCADE)
* 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장(즉시로딩, 지연로딩과는 전혀 관계 없음~~)
* 연관관계에서 cascadeType 을 지정해주면 연속적으로 쿼리가 수행된다.
* 고아 객체 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티
* 개념적으로 부모를 제거하면 자식은 고아객체가 된다. 고아 객체도 같이 삭제되도록 해야 한다. orphanRemoval=true
* 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거, CascadeType.ALL과 orphanRemoval=true로 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음!
DDD의 Aggregate Root개념을 구현할 때 유용! < 먼지모르겠음