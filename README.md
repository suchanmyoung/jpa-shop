### 양방향 연관관계
* 핵심은 단방향을 잘 설계하는 것이 중요하다.
* 비즈니스적으로 조회를 편하게 하기 위해 양방향 연관관계를 지정하는 것

### 다양한 연관관계
* 다대다 관계는 실무에서 쓰면 안 되는 수준

### 프록시와 연관관계
* 프록시
  * em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
  * em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 - DB에 쿼리가 안 날아가는데 객체가 조회
  * 실제 클래스를 상속 받아서 만들어지고 실제 클래스와 겉 모양이 같음.
  * 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용
  * 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것이 아니라 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
  * instance of 를 사용해야 한다
    * instance of 는 상속 관계에 있는 객체를 두고 자식 여부를 확인하는 것, ==은 서로 다른 객체의 주소값의 일치 여부
    * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 실제 엔티티를 반환한다.
  * **프록시를 사용하는 이유 !! Member는 Team과 연관관계를 가짐. 프록시를 사용하지 않아서 지연로딩을 사용할 수 없다면 Member를 JPA를 통해 조회할 때 연관관계인 Team까지 조회된다.
이게 문제가 되는 이유는, Member를 조회해서 어떤 로직을 처리하려는데 Team과 전혀 관련없는 일을 할 때. 나는 member만 필요한데 연관관계인 Team까지 다 불러와서 메모리에 올라와있는 것임. 만약 프록시
를 사용해서 지연로딩을 사용한다면, Member를 조회하고 Team과 전혀 관련없는 로직을 처리할 때 오로지 Member의 상태만으로 로직을 처리. getId를 하면 Id만 그 때 쿼리가 실행돼서 조회되니까!!**